\chapter{Ant-Based Community Detection}\label{abcd}
\pagestyle{myheadings}\markboth{}{\small \ref{abcd} ANT-BASED COMMUNITY DETECTION}
\begin{spacing}{1.5}
In this chapter, we describe our ant-based approach for detecting communities in complex networks. The input to the algorithm is an undirected graph $G=(V, E)$ and the expected output is a (weighted) graph representing the community structure of $G$. The algorithm is divided into three main phases: \emph{exploration}, \emph{construction} and \emph{optimization}. In the exploration phase, the ants traverse the graph and lay pheromone along the edges as they travel. The construction phase is used to build an initial set of communities based on the pheromone level on the edges after the exploration phase. Finally, the optimization phase is used to improve the solution produced by the construction phase before returning the community structure of $G$.
\section{Overview}
Our algorithm consists of artificial ants which explore the graph based on a set of rules to discover edges which connect vertices in the same community. Before the exploration phase, an initialization step is used to initialize the pheromone on all edges of $G$ and place an ant on each vertex of $G$. In the exploration phase, ants traverse the graph based on a fixed set of rules for a number of cycles (or iterations) and lay pheromone along the edges. The objective here is to narrow the search space of the problem by discovering edges connecting vertices in the same community. After the exploration phase, the input to the construction phase is the edges of the graph in decreasing order of their pheromone level which are used to build the first set of communities. This set of communities is used as input to the optimization phase which uses local optimization algorithms to improve the solution quality before outputting the final set of communities. An outline of the algorithm is shown in Figure~\ref{fig1}.\\
\input{fig1}
\section{Data Structures}
Before explaining each phase of the algorithm in detail, the various data structures used in it are mentioned to help facilitate the description. The main data structures used are the following:
\begin{itemize}
	\item Graph $G=(V,E)$, whose community structure is to be found
	\item Weighted graph $G_W=(V_W, E_W)$ represents the community structure of $G$
	\item Community object
	\item Ants
\end{itemize} 
The graph consists of a vertex set $V$ and an edge set $E$ and is represented in an adjcacency list format. Each edge is augmented with its pheromone level ($phm$), the number of times it has been traversed by an ant since the last ($num\_visited$) and its initial pheromone level ($init\_phm$). Each vertex is augmented with information regarding how many vertices are adjacent to it ($neighbors$) and the number of vertices it has in common with each of its neighbors ($common$).\\
\indent The weighted graph $G_W$ also consists of a vertex sex $V_W$ and edge set $E_W$. However, each vertex in $V_W$ represents a community and $E_W$ represents the edges between different communities. Hence, $G_W$ can be thought of as a compacted version of the original graph representing its community structure. Each vertex in $V_W$ is augmented with a list of the communities adjacent to it, the sum of the pheromone level of the edges that are within a community ($internal\_phm$), the number of edges that are within that community ($internal\_edges$), the total pheromone of that community ($total\_phm$) which is equal to $internal\_phm$ plus the pheromone level along each outgoing edge to an adjacent community. Since there may be multiple edges between vertices in different communities in the original graph, they are collapsed into one weighted edge in $G_W$. Each edge $(A, B) \in E_W$ stores the pheromone level between two communities ($edge\_phm$) and the number of edges from the original graph that are between the two communities ($edge\_count$).\\
\indent The Community object consists of the following elements. A vector called \emph{membership} is used to keep track of the community assignment of each vertex $v \in V$. Two vectors are used to maintain the internal degree of each vertex to its community ($in\_degree$) and its external degree to the different communities it might be connected to ($out\_degrees$). The last element in this object, called $vertex\_strength$, which represents the difference between the indegree of a vertex to its community and the total outdegree to vertices outside its community.\\
\indent The set of ants $A$ has a fixed cardinality, equal to the number of vertices in the graph. Each ant maintains its current location ($location$) which is a vertex in $V$ and a tabu list which stores the most recently visited vertices.\\
\indent So far we have given an outline of the algorithm and presented its main data structures. The next section describes each phase of the algorithm in detail, starting with the initialization step.
\section{Initialization}
The input to this step is $G=(V, E)$. Here, the algorithm initializes the set of ants and places each ant on a vertex of the graph and sets the tabu list of each ant to be empty. The initial pheromone level of each edge is initialized to 1 so that all edges of the graph are equally likely to be chosen in the beginning of the exploration phase. The minimum pheromone level is also set to 1 as we do not want the pheromone level of an edge to get too low which would prevent it from getting selected in future iterations.\\
\indent After the above step, the algorithm calculates the number of vertices a vertex has in common with each of its neighbors. Since each vertex maintains a list of neighbors, the number of common vertices can be computed by a simple set intersection operation. In order to compute the intersection quickly, the list of neighbors for each vertex is sorted. The initialization phase is shown in Figure~\ref{fig1}.
\section{Exploration}
Once the initialization step is completed, the exploration phase starts where the ants traverse the graph and lay a trail of pheromone along the edges. The exploration is carried out for a fixed number of iterations. The aim here is to discover edges connecting vertices in the same community and mark them with a high level of pheromone. At the end of the exploration phase, the edges with high level of pheromone are selected to build an initial set of communities. An outline of the exploration phase is shown in Figure~\ref{fig2}.\\
\indent In each iteration, the ants are moved for a fixed number of steps. In each step all the ants are moved in parallel and this is repeated until a specified number of steps are completed.  To increase efficiency, the pheromone level of the edges is updated only after $k$ steps, where $k$ is a fixed constant.\\
\indent In each step, each ant selects the next vertex to move to depending upon the pheromone level of the edges incident to its current location. Since we have defined communities to be subset of vertices where each vertex has more edges to vertices in its own community, we expect two adjacent vertices to be in the same community if they have more vertices in common from their set of neighbors. Hence, an ant selects an edge with a probability that is proportional to the pheromone level of the edge and the size of the neighborhood overlap with the vertex that the edge leads to. This process of selection, called \emph{proportional selection}, favors edges connecting two vertices which might be in the same community and at the same time an edge connecting two vertices in different communities can also be chosen, but with a smaller probability. When an ant traverses an edge leading to another vertex, the pheromone level of the edge is marked to be updated by incrementing the number of times it has been traversed ($num\_visited$) during that step and the vertex that edge leads to is added to the ant's tabu list to avoid returning to that vertex for a fixed period of time.\\
\input{fig2}
\indent We employ a few mechanisms to avoid getting caught in local optima. First, each ant maintains a tabu list which is a fixed length circular queue that stores the most recently visited vertices by the ant. If an ant selects an edge leading to a vertex already present in its tabu list, it attemps to choose another edge. The number of such attempts made by an ant is specified by the paramter $max\_tries$. Second, the pheromone level of each edge is evaporated periodically by a certain factor ($\eta$). In the beginning, the evaporation rate is high so as to encourage exploration and it is gradually decreased after every iteration to help the ants converge on a good set of edges. Finally, the minimum pheromone level of an edge is set to 1 as we do not want the pheromone level of an edge to become so low that it may not be considered during successive iterations.\\
\indent We have mentioned previously that the pheromone level of an edge is updated after a fixed number of steps. Each edge keeps track of the number of times it has been traversed since the previous pheromone update. This value is used along with the current pheromone level during the update step. The formula is the same as that used in~\cite{5910378}:
\begin{align}
e.phm = (1 - \eta)e.phm + e.num\_visited \times e.init\_phm
\end{align}
where $e$ is the edge in the graph being updated, $phm$ is the pheromone level of $e$, $\eta$ is the evaporation rate, $num\_visited$ is the number of times the edge was traversed since the last pheromone update and $init\_phm$ is the initial pheromone level, in this case $init\_phm = 1, \forall e \in E$.\\
\indent At the end of each iteration, two operations are performed. First, the pheromone evaporation factor, $\eta$, is updated by a constant factor, $\Delta\eta$, as explained above. The initial value of $\eta$ is set to 0.5 and $\Delta\eta$ is set to 0.95. Second, the ants are reset before the start of the next iteration. About half the ants stay in their current location while the other half are assigned a random vertex as shown in Figure~\ref{fig3}. The maximum number of steps during each iteration of the exploration phase is set to $\min\{75, \frac{2|V|}{3}\}$.
\input{fig3}
\section{Construction}
So far we have described the initialization and exploration phase of the algorithm. The next phase of the algorithm is to build an initial set of communities based on the pheromone level of the edges.\\
\indent At the end of the exploration phase we expect the edges connecting vertices in the same community to have a high level of pheromone. The construction phase utilizes these edges to build the initial set of communities. We sort the edge set in decreasing order of pheromone level and use that as input to the construction phase. To obtain the initial community structure we build the weighted graph $G_W$. The algorithm reads in the edges $(i, j)\in E$ in sorted order. If both $i$ and $j$ have not been assigned a community, then they are assigned to a new community. If one of $i$ and $j$ is assigned to a community but the other is not, we add it to that community. If both $i$ and $j$ are in separate communities, say $A$ and $B$, respectively, then we create the weighted edge $(A, B) \in E_W$ if it does not exist and set $edge\_count(A, B)$ to 1, or increment $edge\_count(A,B)$ by 1 if the weighted edge $(A, B)$ is already present in $G_W$. We also update $edge\_phm(A, B)$ of the weighted edge by the pheromone level of the edge ($i, j) \in E$. The procedure for building the first set of communities is shown in Figure~\ref{fig4}. \input{fig4}\\
\indent At the end of this phase we obtain the weighted graph which represents the initial set of communites in $G$. This community structure is improved in the local optimization phase by attempting to reassign each vertex's community assignment based on its degree distribution, and merging and splitting different communities. This is done until a fixed number of steps have passed without any improvement. We use modularity as the criterion for measuring improvement in successive iterations. The next section describes the local optimization step in further detail.
\section{Local Optimization}
The input to this phase is the initial set of communities obtained at the previous step. Since the construction phase only utilizes the pheromone level of the edges to build the communities and does not use the structure of the graph, it is likely that the community structure obtained is weak. The local optimization step attempts to improve the solution quality by fine tuning the structure of the weighted graph to fit the definition of a community that we have chosen before outputting the final set of communities in $G$. An outline of the local optimization phase is shown in Figure~\ref{fig5}.\\
%\indent The reassignment step is performed continuously until there is no improvement for a fixed number of iterations. This is followed by merging communities and perturbing them to obtain different configurations while checking for improvement in modularity. If the process of reassignment followed by merging and perturbation does not improve the solution quality for some iterations, we try to break up the communities in order to obtain a different configuration and go back to the reassignment step. The number of times this entire cycle is repeated is determined by a parameter $max\_decrease$.\\
\indent The local optimization phase is divided into four different steps. First is the reassignment step where the algorithm attempts to change each vertex's community assignment based on the indegree of a vertex to its community and the outdegree to vertices in different communities that the vertex may be connected to. The second step involves merging communities in the weighted graph based on how well connected different communities are. The third step perturbs the community assignments of the vertices in $G$ based on each vertex's degree distribution in order to obtain a different configuration. The aim of the perturbation step is to avoid getting stuck in local optima.\\
\indent The first three steps are performed continuously until a fixed number of iterations pass without any improvement. Then, the algorithm goes to the last step which involves breaking up different communities to obtain a different structure. The next sections describe each step in further detail. \input{fig5}
\subsection{Reassignment}
Since the construction phase does not utilize the structural properties of the graph, it is possible that the communities built do not fit the strong definition of a community. The reassignment step attempts to correct this by changing each vertex's community assignment to the community it has more number of edges to. This is repeated until the solution quality does not improve for a fixed number of iterations.\\
\indent Each vertex $v\in V$ keeps track of the indegree to vertices inside its community and outdegree to vertices in other communities. Let the total outdegree of a vertex be equal to the number of edges incident on that vertex which lead to vertices outside its community. We sort $V$ based on the decreasing value of the total outdegree of the vertices. Then for each vertex $v$ in the sorted order, we find the community to which it has the maximum outdegree. Let this community be denoted by $C$. If $v$'s outdegree to $C$ is greater than the indegree to its current community, we change the community assignment of $v$ to $C$.\\
\indent After one round of reassigning is complete, we rebuild the weighted graph representing the current community assignments of the vertices in $G$. If there is an improvement in modularity, then we update the best weighted graph. As mentioned above, the reassignment step is carried out continuously until there is no improvement in modularity for 5 successive iterations. Even after this, the communities may not satisfy the strong community condition. At this point, the algorithm proceeds to the merging step. The reassignment and rebuilding step is shown in Figure \ref{fig:fig6}.\input{fig6}\\
\subsection{Merging}
The input to this step is the weighted graph $G_W$ having the highest modularity from the reassignment step. The current community structure of $G_W$ may be weak as it is possible for a community to be broken up into subcommunities which could be well connected between each other. By merging these subcommunities it is possible to improve the community structure.\\
\indent Let $A$ be a community. We define the following measures:
\begin{itemize}
	\item $internal\_phm(A)$ denotes the total pheromone level of all edges inside community $A$.
	\item $edge\_phm(A, B)$ denotes the pheromone level of the weighted edge $(A, B) \in E_W$ connecting communities $A$ and $B$.
	\item Since $G_W$ is represented as an adjacency list, let $N(i)$ denote the $i$th neighbor of community $A$ in its adjacency list. Let $total\_phm$ denote the sum of $internal\_phm$ and the pheromone along each weighted edge incident to community $A$. It can be written as
\begin{equation}
total\_phm(A) = internal\_phm(A) + \displaystyle\sum_{i = 1}^{d_A}edge\_phm(A, N(i)),\quad(A,N(i))\in E_W,
\end{equation}
where $d_A$ is the degree of community $A$. $total\_phm$ is used to determine the connectivity of a community to its neighbors. If a community is well connected to another one, the fraction of $total\_phm$ along the edge connecting the two communities should be high. The measures which indicate how well connected a community is are defined below.
\item $strength(A) = \frac{internal\_phm(A)}{total\_phm(A)}$, denotes the strength of community $A$. It is used to determine how well connected community $A$ is.
\item Let $strength(A,B)$ denote how well connected two communities $A$ and $B$ are by the weighted edge $(A,B)\in E_W$. It can be written as
\begin{equation}
strength(A, B)=\frac{edge\_phm(A,B)}{total\_phm(A)}+\frac{edge\_phm(A, B)}{total\_phm(B)}.
\end{equation}
\end{itemize}
\indent  Since ants are used to discover intracommunity edges in the exploration phase, we expect the edges between vertices in the same community to have a high level of pheromone.  As a result, the weighted edge $(A, B)\in E_W$ between two well connected communities, $A$ and $B$, in $G_W$ should also have a high level of pheromone ($edge\_phm(A,B)$) as compared to the pheromone level of the weighted edge $(A,B)$ if $A$ and $B$ were weakly connected.\\
\indent We consider community $A$ to be well connected on its own, if $strength(A)$ is above a certain threshold as specified by the parameter $community\_strength$. If $A$ is well connected to another community, $B$, the pheromone level of the weighted edge $(A, B)\in E_W$ should be high and merging $A$ and $B$ should improve the community structure.\\
\indent The main idea while merging communities is to find the edges in $E_W$ which are between two well connected communities. Based on the above observation that two well connected communities in $G_W$ should have a high level of pheromone along the weighted edge connecting them, $strength(A,B)$ should be high for such edges.\\
\indent In the merging step, the algorithm calculates $strength(A,B)$ for each weighted edge $(A,B)\in E_W$ and sorts $E_W$ in decreasing order of $strength(A,B)$. Then for each weighted edge $(A,B)$ in the sorted order, we merge communities $A$ and $B$ if either $strength(A)$ or $strength(B)$ is below the threshold value. The merging step is shown in Figure~\ref{fig7}.\input{fig7}\\
\indent At the end of the merging step the algorithm calculates the new modularity of $G_W$ and updates the best weighted graph if merging the communities increases the modularity. After merging, we proceed to the third step in the optimization phase.
\subsection{Perturbation}
So far the local optimization algorithms reassign the communities for vertices based on their degree distribution and merge different communities based on the criteria specified in the previous section. The next step perturbs the community structure of the weighted graph in order to obtain a different configuration to avoid getting stuck in local optima.\\
\indent The input to the perturbation step is the current best weighted graph. Here the algorithm attempts to create a different community structure by changing the community assignment of those vertices which are on the fringes of their respective communities. We consider a vertex to be on the fringe of its current community if the difference between the vertex's indegree to its community and its total outdegree to vertices in different communities is small, in the range [0, 2]. By perturbing the community assignments of such vertices, it is possible to obtain a different configuration without changing the current community structure drastically.\\
\indent Each vertex $v\in V$ maintains the difference between its indegree relative to the community that it belongs to, and total outdegree in an element called $vertex\_strength$ (see Section 3.2). At this step, we also maintain a tabu list for each vertex which is a fixed length circular queue storing the most recently assigned communities for each vertex during the perturbation step. This tabu list should not be confused with the tabu list maintained by the ants during the exploration phase.\\
\indent The perturbation is performed as follows. For each vertex $v\in V$, we check if $vertex\_strength[v]$ lies in between 0 and 2. If yes, then we find the community $C$ to which $v$ has the maximum outdegree. Let the outdegree of $v$ to $C$ be denoted by $d_C^{out}(v)$. If $C$ is present in $v$'s tabu list then we consider the next vertex in $V$, otherwise we carry out the following steps. If $d_C^{out}(v) > 2\times vertex\_strength[v]$, then we change the community assignment of $v$ to $C$ and add $C$ to $v$'s tabu list to avoid choosing this community for a fixed period of time. Since it is possible that $v$'s total outdegree could be split between multiple communities, we only perturb its community assignment if $d_C^{out}(v)$ is greater than $2\times vertex\_strength[v]$. The perturbation step is shown in Figure~\ref{figure8}.\input{fig8}\\
\subsection{Splitting Communities}
\indent If the perturbation step results in an increase in modularity then the best weighted graph is updated. At the end of the perturbation step we go back to the reassignment step if the number of iterations without improvement is less than the parameter $max\_decrease$. However, if this threshold is exceeded the algorithm goes to the next step in the local optimization phase which involves splitting the communities. \\
\indent The input to this step is the best weighted graph obtained after the first three steps in the local optimization phase have run for a number of iterations until there is no improvement. In order to break up a community, the algorithm needs a starting point or a seed for the new community. We decided to use a 4-clique, which is a fully connected subgraph of 4 vertices, as the seed.\\
\indent For each community in the best weighted graph, we try to build a 4-clique using the vertices of the original graph $G$ in the community. A greedy approach is used to build the clique: starting with the vertex whose degree is highest in the current community, we add its neighbor with the highest degree to the current potential clique and repeat until we have added four vertices to the potential clique or we cannot chose any other vertex at which point we restart building the clique using the vertex with the next highest degree in that community. If the potential clique of size 4 is actually a clique, then we use this clique as the seed for the new community. Let the new community be denoted by $C$.\\
\indent For all the remaining vertices in the current community under consideration which are not included in $C$, we compute their outdegree to $C$ and indegree to the current community as these values change due to the removal of the 4-clique. If the outdegree of a vertex $v$ in the current community to $C$ is higher than the indegree of $v$ to its current community, the community assignment of $v$ is changed to $C$ and the in and out degrees of all its adjacent vertices are updated to reflect this change. This way, groups of vertices in each community which are well connected to the clique are assigned a new community. The splitting step is shown in Figure~\ref{fig:fig9}. \input{fig9}\\
\indent After this procedure is repeated for all communities in the weighted graph, we recompute the modularity to check for improvement. If the modularity improves, then we update the best solution obtained so far. Otherwise we go back to the reassignment step. As mentioned for other steps in the local optimization, the splitting of communities is attempted until the modularity does not improve for a number of iterations. Once the threshold is exceeded, we terminate the algorithm and return the best weighted graph $G_W^*$.

\section{Parameters}

The previous sections covered the various steps involved in the ant based algorithm for finding communities. During the description we mentioned several parameters which are used in the implementation and this section provides a list of them. The various parameters in the algorithm are mentioned in Table ~\ref{tab1}. These parameters are not for a single type of graph but have been used for all graphs on which the algorithm is tested. Some of these parameters are adopted from~\cite{5910378}.\\
\begin{table}
\caption{Parameters in the algorithm}
\scriptsize
\BlankLine
\begin{tabular}{ | c | c | l | }
	\hline
	\textbf{Parameter} & \textbf{Value} & \textbf{Comments}\xtra\\
	\hline
	$i_{max}$ & 25 & Maximum number of iterations during the exploration phase\xtra\\
	\hline
	$max\_steps$ & $\min\{\frac{2|V|}{3}$, 75\} & Maximum number of steps in each iteration\xtra\\
	\hline
	$\eta$ & 0.5 & Pheromone evaporation rate \xtra\\
	\hline
	$\Delta\eta$ & 0.95 & Pheromone update constant \xtra\\
	\hline
	$update\_period$ & $max\_steps / 3$ & Number of cycles between pheromone update \xtra\\
	\hline
	$LIST\_SIZE$ & 2 & Tabu list size\xtra\\
	\hline
	$max\_decrease$ & 3 & Number of steps without improvement\xtra\\
	\hline
	$community\_strength$ & 0.25, 0.35 or 0.80 & Threshold for a community\xtra\\
	\hline
	$max\_tries$ & 2 & Number of attempts to move made by an ant in each step\xtra\\
	\hline
\end{tabular}
\label{tab1}
\end{table}
\indent The parameter $community\_strength$ is used to determine whether a community in the weighted graph is well connected on its own during the merging step. Its value is fixed based on the edge density (as a percentage), $\delta(G)$, of the graph whose community structure is to be found. It is defined as follows
\begin{equation}
\delta(G) = \frac{2|E|}{|V||V-1|}\times 100
\end{equation}
where $|E|$ is the number of edges in $G$ and $|V|$ is the number of vertices in $G$. The value of $\delta(G)$ depends on the graph under consideration. For complete graphs, where every pair of vertices is connected by an edge, the value is 100. Since complex networks are sparse, the value of $\delta(G)$ is usually much lower. $community\_strength$ is then defined as follows
\begin{equation}
community\_strength = 
	\begin{cases}
	0.8, & \text{if } \delta(G) < 0.1\\
	0.35, & \text{if } 0.1 \leq \delta(G) \leq 1\\
	0.25, & \text{if } \delta(G) > 1
	\end{cases}
\end{equation}
If $G$ is very sparse ($\delta(G) < 0.1$), then $community\_strength$ is set to a high value. Since intracommunity edges have a high level of pheromone, a lower threshold will always be crossed since $G$ has a very low edge density. This will prevent communities from merging, leading to a large number of small communities (of sizes 2 or 3).\\
\indent The value of $\delta(G)$ is calculated when the algorithm reads the graph $G$, so the value of $community\_strength$ is set during runtime making the algorithm self-adaptive.\\
\indent We tried several values for the maximum number of iterations, $i_{max}$, ranging from 25 to 100. The running time of the algorithm is directly affected by this parameter and we noticed that a value of 25 and above for $i_{max}$ did not improve the results obtained. Hence this parameter is fixed to 25.\\
\indent In this chapter we have described an ant-based algorithm for finding communities in complex networks in detail. The following chapter describes the methods used for generating synthetic graphs with known community structure in order to test community detection algorithms. It also describes the metric used for evaluating the results obtained by an algorithm against this known structure and presents more information about modularity, which is the quality metric used to evaluate the community structure obtained on real world networks whose community structure is not known.

\section{Running Time Analysis}

The running time of our algorithm can be determined by analysing the running time of each phase in the algorithm. Let $n$ be the number of vertices in the graph $G$ and $m$ be the number of edges. Let $d_i$ be the degree of the $i$th vertex in $V$.\\ 
\indent For the initilization step, sorting the neighbors of $i$ takes $O(d_i\log d_i)$. Since this is done for each vertex in the graph, the total time for this step is $\displaystyle\sum_{i=1}^n d_i\log d_i$. Since we know that $\displaystyle\sum_{i=1}^n d_i = 2m$, the total time is $O(m\log m)$. The next step involves calculating the neighborhood overlap size for each vertex in the graph. Since the neighbors are sorted, computing the set intersection for the vertices takes $\displaystyle\sum_{i\in V} d_i^2$. This is because in the worst case we need to iterate over the list of neighbors for a vertex till its end. Since we end up considering each pair of vertices twice as we compute the intersection, the total time for this operation is $2\displaystyle\sum_{i\in V} d_i^2$. We can see that
\begin{align}
 2\displaystyle\sum_{i\in V} d_i^2 &\leq 2(d_1+\cdots+d_n)^2\\
%& \text{Since } d_1+\cdots+d_n = 2m\\
 \Rightarrow 2\displaystyle\sum_{i\in V} d_i^2 &= O(m^2), \quad \text{as } d_1+\cdots+d_n = 2m.
\end{align}
Hence the total time taken in the initialization step is $O(m^2)$.\\
\indent The exploration phase involves moving the ants and updating the pheromone. Pheromone update takes $O(m)$, assuming each update operation takes $O(1)$.  If an ant is on vertex $i$, based on proportional selection, choosing the next edge to traverse takes $O(d_i)$. Since this is repeated for each ant for a fixed number of steps, the total time is $\displaystyle\sum_{i=1}^nd_i = O(m)$. The reset step takes $O(n)$. Hence the total time for the exploration phase is $c_1(O(n+m))$ where $c_1$ is the number of cycles in the exploration phase.\\
\indent The construction phase involves sorting the edges in decreasing order of pheromone. This takes $O(m\log m)$ followed by building the initial weighted graph which takes $O(m)$. Hence the total time taken in the construction phase is $O(m\log m)$.\\
\indent In the local optimization phase, the reassignment step takes $O(n\log n)$ to sort the vertices in decreasing order of total outdegree. Reassigning each vertex $i\in V$ takes $O(d_i)$ and this is done for $n$ vertices after which we rebuild the weighted graph. The running time for this part is $\displaystyle\sum_{i=1}^nd_i + O(m) = O(m)$. So the total time for the reassignment step is $O(n\log n+m)$.\\
\indent Let $m'$ be the number of edges in $G_W$ and $n'$ be the number of vertices. The merging step calculates $strength(A, B)$ for each weighted edge $(A, B)\in E_W$, this takes $O(m')$. Sorting all the weighted edges based on the value of $strength(A, B)$ takes $O(m'\log m')$. Merging a vertex $A$ with another vertex $B$ involves updating the degree of each neighbor of $A$ which takes $O(d_A)$. Since we consider every vertex in the weighted graph, the merging procedure takes $\displaystyle\sum_{A=1}^{n'} d_A = O(m')$. Hence, the total running time of the merging step is $O(m'\log m')$. Since $m'\leq m$, we can rewrite the running time as $O(m\log m)$.\\
\indent The perturbation step attempts to reassign the community of each vertex $i\in V$. It takes $O(d_i)$ to reassign a vertex and this is attempted for all vertices. The total time taken for this part is $\displaystyle\sum_{i=1}^n d_i = O(m)$. Rebuilding the new weighted graph takes $O(m)$. So the total time taken for the perturbation step is $O(m)$.\\
\indent The splitting communities step attempts to break up each community in $G_W$, by using a 4-clique as a seed for the new community. For each community $A \in V_W$, we first sort the vertices in $A$ based on decreasing order of their degree, this takes $O(|A|\log|A|)$. The time taken to build the clique is $O(|A|)$. This is because we consider each vertex in $|A|$ and try to add it to the clique $C$, whose size is no more than 4. This test is no more than $O(1)$ time. Recalculating the in and out degrees of each vertex in $A-C$ relative to the community $A$ takes $\displaystyle\sum_{i\in A-C}d_i$. Attempting to reassign each vertex in $A-C$ to $C$ takes $O(1)$ time. But if we reassign a node, we update the degrees for all its neighbors and as a result this step also takes $\displaystyle\sum_{i\in A-C}d_i$. Thus, the time taken to build a clique $C$ and reassign the vertices of community $A$ is
\begin{align}
O(|A|\log|A|) + O(|A|) + 2\displaystyle\sum_{i\in A-C}d_i.
\end{align}
We repeat the above procedure for each community in $G_W$. Since $|A|\leq n$, the first term is no more than $O(n\log n)$. Similarly, the second term is no more than $O(n)$. The last term is no more than $2\displaystyle\sum_{i\in V}d_i = 4m$, so it reduces to $O(m)$. Thus, the running time of splitting step is $O(m+n\log n)$.\\
\indent The total time taken in the local optimization phase is the sum of the time taken for all 4 steps. Based on the above observations, the running time of the local optimization phase is $O(m\log m+n\log n)$.\\
\indent The overall running of the time algorithm can now be written as $O(m^2) + c_1(O(n+m))+O(m+n\log n)+c_2(O(m\log m+n\log n))$, where $c_2$ is the number of times the local optimization phase is executed. Thus, the running time is $O(m^2+n\log n)$. Since most real world networks have $m=O(n)$, the overall running time is $O(n^2)$.
\end{spacing}