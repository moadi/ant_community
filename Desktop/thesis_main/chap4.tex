\chapter{Benchmark Graphs}\label{bnch}
\pagestyle{myheadings}\markboth{}{\small \ref{bnch} BENCHMARK GRAPHS}
\begin{spacing}{1.5}
In order to test a community detection algorithm, it is necessary to compare its performance against other existing methods. Since community detection algorithms usually output some community structure for any input graph, it is also necessary to evaluate how good that structure is. In the field of community detection, while the intuitive idea of a community is considered the same, there are currently a wide range of methods available which employ different techniques to solve this problem, and as a result they tend to produce different outputs for the same network. Due to this it is necessary to use benchmark graphs whose community structure is known, to be able to test different community detection algorithms.\\
\indent We have mentioned earlier that the metric adopted to evaluate the community structure for real world graphs is modularity as we don't know the real community structure of such networks. Since the community structure for synthetic graphs is known, we can use a different metric to evaluate community structure found by an algorithm by comparing it against the known community structure of the synthetic graph to determine how similar they are.\\
\indent Before describing the metric for synthetic graphs, this chapter discusses two benchmarks for generating synthetic graphs with known community structure. The last section discusses the drawbacks of modularity.
\section{Synthetic Graphs}
One of the most commonly used method for generating graphs with known community structure is the planted $\ell$-partition model~\cite{RSA:RSA1001}. This model partitions a graph with $n = g \cdot \ell$ vertices into $\ell$ communities with $g$ vertices each. A vertex is linked to others in its own community with probability $p_{in}$ and to those outside its community with probability $p_{out}$. If  $p_{in} > p_{out}$ then the number of intracommunity edges are higher and the graph has a community structure.
\subsection{Girvan-Newman Benchmark}
\indent The Girvan-Newman benchmark~\cite{Girvan11062002} is a special case of the planted $\ell$-partition model where $n = 128$, $\ell = 4$ and the average degree of each vertex is 16.  This was the first benchmark suggested for testing community detection algorithms so it was quickly adopted to test community detection algorithms .\\
\indent Tests on this benchmark were performed by increasing the outdegree of each vertex in each instance. Since the degree of each vertex is fixed to 16, when the outdegree is set to 8 each vertex has as many connections to nodes in its own community as to those outside it and as a result the community structure is very fuzzy. Due to this most algorithms begin to fail at this value for the outdegree.\\
\indent Even though this benchmark became very popular, it is evident that its structure is too simple. In particular, it does not possess the properties attributed to complex networks, such as power-law degree distributions, heterogeneous community sizes etc. The need for benchmarks having these properties became necessary. The LFR Benchmark, which is described next, was proposed to address this issue.
\subsection{LFR Benchmark}
The LFR benchmark~\cite{PhysRevE.78.046110} is an improvement over the Girvan-Newman benchmark as it takes into account the structure of complex networks and thus is more representative of networks found in real life. It is also a special case of the planted $\ell$-partition model where group sizes and node degrees vary according to a power law. This poses a much harder test for community detection algorithms.\\
\indent This benchmark possesses a variety of parameters. We can specify the number of nodes in the graph, their average and maximum degrees, maximum and minimum community sizes. The benchmark assumes that degree distributions and community sizes follow a power-law whose exponents are $\gamma$ and $\beta$ respectively. $\gamma$ is usually set in the range [2, 3] whereas $\beta$ is in the range [1, 2]. As mentioned in Chapter 1, the degree distribution of a graph is the probability distribution of the degrees of all vertices in the graph. Power-law implies that the degree distribution varies as a power of the degree of the vertices. If $P(d)$ is the probability distribution function of vertices having degree $d$, then $P(d)\approx d^{-\gamma}$, $d > 0$ and $\gamma > 0$. The community size distribution is defined similarly. The most important parameter here is called the mixing parameter, denoted by $\mu$, which specifies what fraction of its edges a vertex shares with vertices outside its community. If $d(i)$ is the degree of the $i$th vertex in the synthetic graph with a certain $\mu$, the internal degree of vertex $i$ relative to its community is $(1-\mu)d(i)$ and its external degree is $\mu d(i)$. As a result, the mixing parameter denotes how well connected the communities in the synthetic graph are between each other.\\
\indent We can generate different instances by varying $\mu$ to make the communities fuzzy and harder to detect. The technique to generate the graphs is fast, of the order $O(m)$, where $m$ is the number of edges in the graph. The LFR benchmark is known to pose a harder test for community detection algorithms and is the benchmark we have adopted for testing our ant based algorithm as well. In the next section we describe metrics to evaluate the community structure obtained by different algorithms for synthetic graphs and real world networks.
\section{Community Structure Evaluation}
\subsection{Normalized Mutual Information}
Since we already know the community structure for synthetic graphs, we can use that information for comparing how similar the community structure obtained by an algorithm is to the planted communities in the graph.\\
\indent For synthetic graphs the most widely adopted quality metric is the Normalized Mutual Information (NMI), as described in~\cite{Danon05comparingcommunity}. Here we define a \emph{confusion matrix} $N$, where the rows correspond to the ``planted'' communities and the columns correspond to the communities found by an algorithm. $N_{ij}$ represents the number of nodes in the $i$th planted community that appear in the $j$th found community. Let $\mathcal{P} = \{A_1,\ldots,A_k\}$ denote the set of planted communities in the graph and $\mathcal{F} = \{B_1,\ldots,B_l\}$ denote the set of communities found by an algorithm. Let $n$ denote the number of vertices in the synthetic graph. The NMI, denoted by $I(\mathcal{P}, \mathcal{F})$, based on information theory is defined as follows:
\begin{equation}
\hspace*{-5 cm} I(\mathcal{P}, \mathcal{F}) = \frac{-2 \sum_{i=1}^{k} \sum_{j=1}^{l} N_{ij} \log\left ( \frac{n N_{ij}}{|A_i| |B_j|} \right )}{\sum_{i=1}^{k} |A_i| \log \left ( \frac{|A_i|}{n} \right ) + \sum_{j=1}^{l} |B_j| \log \left ( \frac{|B_j|}{n} \right )}
\end{equation}
where $|A_i|$ denotes the cardinality of the $i$th planted community and $|B_j|$ denotes the cardinality of the $j$th found community.\\
\indent If the found set of communities is identical to the planted one then $I(\mathcal{P}, \mathcal{F}) = 1$, which is its maximum value. If the found set of communities is totally independent of the planted one then, $I(\mathcal{P}, \mathcal{F}) = 0$.
\subsection{Modularity}
As described in Chapter 2, modularity is a widely adopted quality metric for evaluating the community structure obtained on real world networks. We cannot calculate the NMI on such networks as we do not have prior information about the real community structure of such networks.\\
\indent Modularity is calculated by computing the fraction of edges that fall within a community as compared to the fraction if the vertices in a community were connected randomly keeping the same degree sequence. It was assumed that high modularity structures correspond to a good community structure which is the motivation behind modularity optimization algorithms.\\ 
\indent Despite the huge popularity of modularity optimization methods due to their speed and thus allowing the opportunity to analyze very large networks, its properties have been recently investigated which brought forward a few drawbacks.\\
\indent Fortunato and Barth\'{e}lemy~\cite{Fortunato02012007} showed that modularity suffers from a resolution limit. They found that modularity maximization favors community structures where several subcommunities are aggregated into one community. Modularity fails to indentify communities smaller than a certain scale which depends on the size of the network and the connectedness of the communities. This contradicts the notion of a community being a local measure instead of a global one. To this extent, they compared the communities found using modularity optimization by simulated annealing~\cite{Guimera04simulatedAnnealingNetworks} and then reapplied the method on each community returned by the algorithm. They found that most communities themselves had a clear community structure with high modularity values. As a result, the final number of communities obtained were much more than the ones reported by modularity maximization.\\
\indent Good et al.~\cite{PhysRevE.81.046106} further examined the performance of modularity maximization and apart from the resolution limit they found two other drawbacks. First, there are an exponential number of structurally diverse alternate community structures whose modularity is very close to the maximum, this is called the degeneracy problem. This explains the good performance of modularity maximization methods as they are able to discover a high ranking community structure depending on the implementation and explains the reason why different algorithms can have widely varying outputs for the same network. Second, the maximum modularity $Q_{max}$ depends upon the size of the network and the number of communities it contains. This means that the maximum of modularity is dependent upon the topology of the network under consideration.\\
\indent In this chapter we have covered the techniques used for generating various synthetic graphs and methods to evaluate the output of community detection algorithms. The next chapter presents the experimental results of the ant based algorithm on the LFR benchmark and several real world networks and compares its performance against six well known community detection algorithms.
\end{spacing}